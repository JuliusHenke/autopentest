import asyncio
import functools
import operator
from typing import TypedDict, Annotated, Sequence

from dotenv import load_dotenv
from langchain_core.messages import HumanMessage, BaseMessage
from langgraph.graph import END, StateGraph

from src.agents.agent_creation import create_task_specific_agent_executor
from src.agents.agent_supervisor import supervisor_chain
from src.agents.task_specific_agents import TaskSpecificAgent, task_specific_agents, \
    task_specific_agent_names

# Load environment variables
load_dotenv()


# The agent state is the input to each node in the graph
class AgentState(TypedDict):
    # The annotation tells the graph that new messages will always
    # be added to the current states
    messages: Annotated[Sequence[BaseMessage], operator.add]
    # The 'next' field indicates where to route to next
    next: str
    question: str


async def agent_node(state: AgentState, agent, name):
    try:
        result = await agent.ainvoke(state)
        return {"messages": [HumanMessage(content=result["output"], name=name)]}
    except Exception as e:
        return {"messages": [HumanMessage(content=f"Error: {e}", name=name)]}


workflow = StateGraph(AgentState)


def __create_agent_and_add_to_workflow(agent: TaskSpecificAgent):
    agent_executor = create_task_specific_agent_executor(agent)
    agent_node_fn = functools.partial(agent_node, agent=agent_executor, name=agent_executor.name)
    workflow.add_node(agent.name, agent_node_fn)
    return agent_executor


for task_specific_agent in task_specific_agents:
    __create_agent_and_add_to_workflow(task_specific_agent)
workflow.add_node("supervisor", supervisor_chain)

for member in task_specific_agent_names:
    # We want our workers to ALWAYS "report back" to the supervisor when done
    workflow.add_edge(member, "supervisor")
# The supervisor populates the "next" field in the graph state
# which routes to a node or finishes
conditional_map = {k: k for k in task_specific_agent_names}
conditional_map["FINISH"] = END
workflow.add_conditional_edges("supervisor", lambda x: x["next"], conditional_map)
workflow.set_entry_point("supervisor")

graph = workflow.compile()

# Usage example
async def main():
    async for s in graph.astream(
            {"messages": [HumanMessage(
                content="Search for the latest broken access control vulnerabilities. Then get details for one CVE.")]},
            {"recursion_limit": 10},
    ):
        if "__end__" not in s:
            print(s)
            print("----")


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())