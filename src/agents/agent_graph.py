import functools
import operator
from typing import Sequence, TypedDict, Annotated

from dotenv import load_dotenv
from langchain_core.messages import BaseMessage, HumanMessage
from langgraph.graph import END, StateGraph

from agent_creation import create_agent, agent_node, llm
from agent_supervisor import supervisor_chain
from task_specific_agents import TaskSpecificAgent, task_specific_agents, \
    task_specific_agent_names

# Load environment variables
load_dotenv()


# The agent state is the input to each node in the graph
class AgentState(TypedDict):
    # The annotation tells the graph that new messages will always
    # be added to the current states
    messages: Annotated[Sequence[BaseMessage], operator.add]
    # The 'next' field indicates where to route to next
    next: str


workflow = StateGraph(AgentState)


def __create_agent_and_add_to_workflow(agent: TaskSpecificAgent):
    agent_executor = create_agent(llm, agent.tools, agent.system_prompt)
    agent_node_fn = functools.partial(agent_node, agent=agent_executor, name=agent_executor.name)
    workflow.add_node(agent.name, agent_node_fn)
    return agent_executor


for task_specific_agent in task_specific_agents:
    __create_agent_and_add_to_workflow(task_specific_agent)
workflow.add_node("supervisor", supervisor_chain)

for member in task_specific_agent_names:
    # We want our workers to ALWAYS "report back" to the supervisor when done
    workflow.add_edge(member, "supervisor")
# The supervisor populates the "next" field in the graph state
# which routes to a node or finishes
conditional_map = {k: k for k in task_specific_agent_names}
conditional_map["FINISH"] = END
workflow.add_conditional_edges("supervisor", lambda x: x["next"], conditional_map)
# Finally, add entrypoint
workflow.set_entry_point("supervisor")

graph = workflow.compile()

# Usage example
if __name__ == "__main__":
    for s in graph.stream(
            {"messages": [HumanMessage(content="Search for the latest broken access control vulnerabilities. Then get details for one CVE.")]},
            {"recursion_limit": 10},
    ):
        if "__end__" not in s:
            print(s)
            print("----")
