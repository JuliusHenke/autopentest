import asyncio
import functools
import operator
from typing import TypedDict, Annotated, List, Tuple, Literal

from dotenv import load_dotenv
from langchain_core.messages import HumanMessage
from langgraph.graph import END, StateGraph

from src.agents.agent_creation import create_task_specific_agent_executor
from src.agents.planning import planner, replanner, Response, PLANNER, REPLAN
from src.agents.supervision import supervisor_chain, SUPERVISOR
from src.agents.task_specific_agents import TaskSpecificAgent, task_specific_agents, \
    task_specific_agent_names

# Load environment variables
load_dotenv()


# The agent state is the input to each node in the graph
class AgentState(TypedDict):
    # User input
    input: str
    # The 'next' field indicates where to route to next
    next: str
    # The steps to take to reach the user goal
    plan: List[str]
    # Attempted steps
    past_steps: Annotated[List[Tuple], operator.add]
    # Final response from planner if finished
    response: str


async def plan_step(state: AgentState):
    plan = await planner.ainvoke({"messages": [("user", state["input"])]})
    return {"plan": plan.steps}


async def supervise(state: AgentState):
    return await supervisor_chain.ainvoke({"messages": [("user", get_formatted_task(state))]})


async def execute_task(state: AgentState, agent, name):
    task = state["plan"][0]
    messages = [
        HumanMessage(content=state["input"], name=name),
        HumanMessage(content=get_formatted_task(state), name=name)
    ]
    if state["past_steps"]:
        messages.append(HumanMessage(content=f"Observations from previous workers: {state['past_steps']}", name=name))
    try:
        agent_response = await agent.ainvoke(
            {"messages": messages}
        )
        output = agent_response["output"]
    except Exception as e:
        output = f"Error executing task: {e}"
    if isinstance(output, list) or isinstance(output, tuple):
        output = output[-1]
    return {
        "past_steps": [(task, output)],
    }


def get_formatted_task(state: AgentState):
    plan = state["plan"]
    plan_str = "\n".join(f"{i + 1}. {step}" for i, step in enumerate(plan))
    task = plan[0]
    return f"""For the following plan:
{plan_str}\n\nYou are only tasked with executing step {1}, {task}."""


async def replan_step(state: AgentState):
    output = await replanner.ainvoke(state)
    if isinstance(output.action, Response):
        return {"response": output.action.response}
    else:
        return {"plan": output.action.steps}


def should_end(state: AgentState) -> Literal[SUPERVISOR, END]:
    if "response" in state and state["response"]:
        return END
    else:
        return SUPERVISOR


def __add_task_specific_agent_to_workflow(agent: TaskSpecificAgent):
    agent_executor = create_task_specific_agent_executor(agent)
    agent_node_fn = functools.partial(execute_task, agent=agent_executor, name=agent_executor.name)
    workflow.add_node(agent.name, agent_node_fn)
    return agent_executor


workflow = StateGraph(AgentState)
workflow.add_node(SUPERVISOR, supervise)

# The planner is only used once as an entry point and reports to the supervisor
workflow.add_node(PLANNER, plan_step)
workflow.set_entry_point(PLANNER)
workflow.add_edge(PLANNER, SUPERVISOR)

# Always replan after a task specific agent is done with its task
workflow.add_node(REPLAN, replan_step)
for task_specific_agent in task_specific_agents:
    __add_task_specific_agent_to_workflow(task_specific_agent)
    workflow.add_edge(task_specific_agent.name, REPLAN)

# The supervisor populates the "next" field in the graph state which routes to a task specific agent or finishes
conditional_map = {k: k for k in task_specific_agent_names}
# conditional_map["FINISH"] = END
workflow.add_conditional_edges(SUPERVISOR, lambda x: x["next"], conditional_map)

# From replan we can either go back to the supervisor or finish
workflow.add_conditional_edges(
    REPLAN,
    should_end,
)

graph = workflow.compile()

# Usage example
async def main():
    async for s in graph.astream(
            {"input": "When did construction for the big tower in paris start and how many workers were involved?"},
            {"recursion_limit": 10},
    ):
        if "__end__" not in s:
            print(s)
            print("----")


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
