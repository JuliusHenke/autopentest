import logging
import platform
from typing import List, Optional, Type, Union

from langchain_core.callbacks import (
    CallbackManagerForToolRun,
)
from langchain_core.pydantic_v1 import BaseModel, Field, root_validator
from langchain_core.tools import BaseTool

from src.tools.bash_process import BashProcess

logger = logging.getLogger(__name__)


class ShellInput(BaseModel):
    """Commands for the Bash Shell tool."""

    commands: Union[str, List[str]] = Field(
        ...,
        description="List of shell commands to run. Deserialized using json.loads. Always use non-interactive commands, if possible.",
    )
    """List of shell commands to run."""

    timeout: int = Field(
        ...,
        description="Timeout in seconds to wait for command execution. Use a realistic timeout to mitigate indefinite blocking.",
    )
    """Timeout in seconds to wait for command execution."""

    @root_validator
    def _validate_commands(cls, values: dict) -> dict:
        """Validate commands."""
        commands = values.get("commands")
        if not isinstance(commands, list):
            values["commands"] = [commands]
        return values


def get_platform() -> str:
    """Get platform."""
    system = platform.system()
    if system == "Darwin":
        return "MacOS"
    return system


def get_default_bash_process(persistent: bool = False, reverse_shell_listener: bool = False) -> BashProcess:
    """Get default bash process."""
    return BashProcess(return_err_output=True, persistent=persistent, reverse_shell_listener=reverse_shell_listener)


class BaseShell(BaseTool):
    """Tool to run one time shell/bash commands in."""

    process: BashProcess = Field(default_factory=lambda: get_default_bash_process(False))
    """Bash process to run commands."""

    name: str = "terminal"
    """Name of tool."""

    description: str = f"Run bash commands on this {get_platform()} machine. Please use a realistic timeout in seconds to mitigate indefinite blocking."
    """Description of tool."""

    args_schema: Type[BaseModel] = ShellInput
    """Schema for input arguments."""

    ask_human_input: bool = False
    """
    If True, prompts the user for confirmation (y/n) before executing 
    a command generated by the language model in the bash shell.
    """

    default_timeout: int = 60

    def _run(
            self,
            commands: Union[str, List[str]],
            timeout: int = default_timeout,
            run_manager: Optional[CallbackManagerForToolRun] = None,
    ) -> str:
        """Run commands with a timeout in seconds and return final output."""

        print(f"Executing commands with timeout {timeout}:\n {commands}")  # noqa: T201

        try:
            if self.ask_human_input:
                user_input = input("Proceed with command execution? (y/n): ").lower()
                if user_input in ["y", "yes"]:
                    return self.process.run(commands, timeout)
                else:
                    return "User denied command execution. Try something different."
            else:
                return self.process.run(commands, timeout)

        except Exception as e:
            return f"Error during command execution: {e}"
