import functools
import operator
from typing import Sequence, TypedDict, Annotated

from langchain_community.tools import ShellTool
from langchain_core.messages import BaseMessage, HumanMessage
from langgraph.graph import END, StateGraph

from openai_functions_agent.agent_creation import create_agent, agent_node
from openai_functions_agent.agent_supervisor import supervisor_chain, llm
from openai_functions_agent.tools.python_repl import python_repl
from openai_functions_agent.tools.tavily_search import tavily_search

from dotenv import load_dotenv

# Load environment variables
load_dotenv()


# The agent state is the input to each node in the graph
class AgentState(TypedDict):
    # The annotation tells the graph that new messages will always
    # be added to the current states
    messages: Annotated[Sequence[BaseMessage], operator.add]
    # The 'next' field indicates where to route to next
    next: str


workflow = StateGraph(AgentState)


def __create_agent_and_add_to_workflow(agent_name: str, system_prompt, tools: list):
    agent = create_agent(llm, tools, system_prompt)
    agent_node_fn = functools.partial(agent_node, agent=agent, name=agent_name)
    workflow.add_node(agent_name, agent_node_fn)
    return agent


shell_tool = ShellTool()
task_specific_agents = ["Generic Penetration Tester"]
__create_agent_and_add_to_workflow("Generic Penetration Tester",
                                   "You are a penetration tester.",
                                   [tavily_search, shell_tool, python_repl])
workflow.add_node("supervisor", supervisor_chain)

for member in task_specific_agents:
    # We want our workers to ALWAYS "report back" to the supervisor when done
    workflow.add_edge(member, "supervisor")
# The supervisor populates the "next" field in the graph state
# which routes to a node or finishes
conditional_map = {k: k for k in task_specific_agents}
conditional_map["FINISH"] = END
workflow.add_conditional_edges("supervisor", lambda x: x["next"], conditional_map)
# Finally, add entrypoint
workflow.set_entry_point("supervisor")

graph = workflow.compile()

if __name__ == "__main__":
    for s in graph.stream(
            {"messages": [HumanMessage(content="Write a brief research report on pikas.")]},
            {"recursion_limit": 100},
    ):
        if "__end__" not in s:
            print(s)
            print("----")
