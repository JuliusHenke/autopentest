import functools
import operator
from typing import Sequence, TypedDict, Annotated

from dotenv import load_dotenv
from langchain_core.messages import BaseMessage, HumanMessage
from langgraph.graph import END, StateGraph

from openai_functions_agent.agent_creation import create_agent, agent_node
from openai_functions_agent.agent_supervisor import supervisor_chain, llm
from openai_functions_agent.task_specific_agents import broken_access_control_agent, cryptographic_failures_agent, \
    injection_agent, insecure_design_agent, security_misconfiguration_agent, vulnerable_and_outdated_components_agent, \
    identification_and_authentication_failures_agent, privilege_escalation_agent, generic_penetration_tester_agent, \
    TaskSpecificAgent

# Load environment variables
load_dotenv()


# The agent state is the input to each node in the graph
class AgentState(TypedDict):
    # The annotation tells the graph that new messages will always
    # be added to the current states
    messages: Annotated[Sequence[BaseMessage], operator.add]
    # The 'next' field indicates where to route to next
    next: str


workflow = StateGraph(AgentState)


def __create_agent_and_add_to_workflow(agent: TaskSpecificAgent):
    agent = create_agent(llm, agent.tools, agent.system_prompt)
    agent_node_fn = functools.partial(agent_node, agent=agent, name=agent.agent_name)
    workflow.add_node(agent.agent_name, agent_node_fn)
    return agent



task_specific_agents = [broken_access_control_agent,
                        cryptographic_failures_agent,
                        injection_agent,
                        insecure_design_agent,
                        security_misconfiguration_agent,
                        vulnerable_and_outdated_components_agent,
                        identification_and_authentication_failures_agent,
                        privilege_escalation_agent,
                        generic_penetration_tester_agent]
task_specific_agent_names = [agent.agent_name for agent in task_specific_agents]

for agent in task_specific_agents:
    __create_agent_and_add_to_workflow(agent)
workflow.add_node("supervisor", supervisor_chain)

for member in task_specific_agent_names:
    # We want our workers to ALWAYS "report back" to the supervisor when done
    workflow.add_edge(member, "supervisor")
# The supervisor populates the "next" field in the graph state
# which routes to a node or finishes
conditional_map = {k: k for k in task_specific_agent_names}
conditional_map["FINISH"] = END
workflow.add_conditional_edges("supervisor", lambda x: x["next"], conditional_map)
# Finally, add entrypoint
workflow.set_entry_point("supervisor")

graph = workflow.compile()

# Usage example
if __name__ == "__main__":
    for s in graph.stream(
            {"messages": [HumanMessage(content="Write a brief research report on pikas.")]},
            {"recursion_limit": 100},
    ):
        if "__end__" not in s:
            print(s)
            print("----")
